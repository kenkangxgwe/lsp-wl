(* ::Package:: *)

(* Copyright 2019 lsp-wl Authors *)
(* SPDX-License-Identifier: MIT *)


(* Wolfram Language Server Table Generator *)


BeginPackage["WolframLanguageServer`TableGenerator`"]
ClearAll[Evaluate[Context[] <> "*"]]


GenerateUnicodeTable::usage = "GenerateUnicodeTable[file_] generates unicode table to file."
GenerateCompletionTable::usage = "GenerateCompletionTable[file_] generates completion table to file."


Begin["`Private`"]
ClearAll[Evaluate[Context[] <> "*"]]


GenerateUnicodeTable[file_] := Block[
    {
        UnicodeCharacters = {
            $InstallationDirectory, "SystemFiles", "FrontEnd", "TextResources", "UnicodeCharacters.tr"
        } // FileNameJoin
        // Import[#, "Text"]&,
        AliasToLongName, LongNameToUnicode
    },

    OpenWrite[file];

    WriteLine[file, "(* "~~"::Package::" ~~ " *)\n"];
    WriteLine[file, "(* This file is generated by WolframLanguageServer`TableGenerator` package. *)\n\n"];
    WriteLine[file, "BeginPackage[\"WolframLanguageServer`UnicodeTable`\"]"];
    WriteLine[file, "ClearAll[Evaluate[Context[] <> \"*\"]]\n\n"];

    AliasToLongName =
    UnicodeCharacters
    // StringCases[
        (("\\[" ~~ longName:(LetterCharacter...) ~~ "]") ~~
        Whitespace ~~ "(" ~~ alias:Shortest[___] ~~ ")") :> {
            alias
            // StringCases["$" ~~ shortname : Shortest[__] ~~ "$" :> shortname],
            longName
        }
    ]
    // DeleteCases[{{}, _}]
    // Map[Apply[Thread@*Rule]]
    // Flatten // Association;

    LongNameToUnicode = UnicodeCharacters
    // StringCases[(
        "0x" ~~ unicode:(HexadecimalCharacter..) ~~ Whitespace ~~
        ("\\[" ~~ longName:(LetterCharacter...) ~~ "]")
    ) :> (longName -> FromDigits[unicode, 16])]
    // Association;

    (* aliases without A-Za-z. *)
    NonLetterAliases = Keys[AliasToLongName]
    // Cases[_?(StringMatchQ[Except[WordCharacter]..])];

    (*
        Non-letters which are only used as prefix of aliases that contains letters.
        We know there is only one such leader, i.e. `$`, but we generate it here.
    *)
    NonLetterLeaders = AliasToLongName
    // Keys
    // Map[StringTake[#, 1] &]
    // StringCases[Except[LetterCharacter]]
    // Catenate
    // Counts
    // Select[# >= 100&]
    // Keys;

    {
        {WolframLanguageServer`UnicodeTable`NonLetterLeaders, NonLetterLeaders},
        {WolframLanguageServer`UnicodeTable`NonLetterAliases, NonLetterAliases},
        {WolframLanguageServer`UnicodeTable`AliasToLongName, AliasToLongName},
        {WolframLanguageServer`UnicodeTable`LongNameToUnicode, LongNameToUnicode}
    }
    (* Use `Function` to do lexical replacement in `Unevaluated` *)
    // Map[Apply[{lhs, rhs} \[Function] (
        Write[file, Unevaluated[lhs = rhs]];
        WriteLine[file, "\n"]
    )]];

    WriteLine[file, "EndPackage[]"];

    Close[file];

]


GenerateCompletionTable[file_] := Block[
    {
        topTokens = {
            $InstallationDirectory, "SystemFiles", "Components", "AutoCompletionData", "Main", "all_top_level.m"
        } // FileNameJoin // Get
    },

    topTokens = {
            $InstallationDirectory, "SystemFiles", "Components", "AutoCompletionData", "Main", "AllChildren"
        }
        // FileNameJoin
        // FileNames[All, #]&
        // Map[Get]
        // Catenate
        // Counts
        // KeyDrop[topTokens]
        // SortBy[Minus]
        // Keys
        // Join[topTokens, #]&;

    OpenWrite[file];

    WriteLine[file, "(* "~~"::Package::" ~~ " *)\n"];
    WriteLine[file, "(* This file is generated by WolframLanguageServer`TableGenerator` package. *)\n\n"];
    WriteLine[file, "BeginPackage[\"WolframLanguageServer`CompletionTable`\"]"];
    WriteLine[file, "ClearAll[Evaluate[Context[] <> \"*\"]]\n\n"];

    {WolframLanguageServer`CompletionTable`TopCompletionTokens, topTokens}
    (* Use `Function` to do lexical replacement in `Unevaluated` *)
    // Apply[{lhs, rhs} \[Function] (
        Write[file, Unevaluated[lhs = rhs]];
        WriteLine[file, "\n"]
    )];

    WriteLine[file, "EndPackage[]"];

    Close[file]
]


End[]


EndPackage[]
